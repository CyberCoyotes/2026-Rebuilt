package frc.robot.subsystems.indexer;

import org.littletonrobotics.junction.Logger;

import edu.wpi.first.networktables.BooleanPublisher;
import edu.wpi.first.networktables.IntegerPublisher;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class IndexerSubsystem extends SubsystemBase {

    // ==== Indexer State =======================================================
    /**
     * IndexerState — Tracks what the indexer is currently doing.
     *
     * Using an enum instead of Strings means a typo is a compile error,
     * not a silent bug. Compare:
     *   "FEEDNG" (compiles, breaks logic silently)
     *   IndexerState.FEEDNG (won't compile — caught immediately)
     */
    public enum IndexerState {
        IDLE,
        FEEDING,
        EJECTING
    }

    // ==== IO Layer ============================================================
    private final IndexerIO io;

    // IndexerIOInputsAutoLogged is generated by @AutoLog on IndexerIOInputs.
    // This subclass implements LoggableInputs, which is what Logger.processInputs()
    // needs to write fields to the AdvantageKit log. Using plain IndexerIOInputs
    // here would silently skip all indexer data in AdvantageScope.
    private final IndexerIOInputsAutoLogged inputs = new IndexerIOInputsAutoLogged();

    // ==== State ===============================================================
    private IndexerState currentState = IndexerState.IDLE;

    // ==== Voltage Constants ===================================================
    // Kept here (alongside the commands that use them) so students can find
    // and tune these without hunting through a separate Constants file.
    //
    // Historical note: a previous IndexerCommands class used FEED_VOLTS=9.6 and
    // CONVEYOR_VOLTS=7.2. Reconcile those values against these on the actual robot.
    public static final double CONVEYOR_FORWARD_VOLTAGE = 4.0;  // TODO: Tune
    public static final double CONVEYOR_REVERSE_VOLTAGE = -4.0;
    public static final double INDEXER_FORWARD_VOLTAGE  = 4.0;  // TODO: Tune
    public static final double INDEXER_REVERSE_VOLTAGE  = -4.0;

    // Jam detection thresholds — uncomment when jam detection logic is enabled below
    // public static final double CONVEYOR_JAM_CURRENT_THRESHOLD  = 20.0; // amps — TODO: Tune
    // public static final double CONVEYOR_JAM_VELOCITY_THRESHOLD = 0.5;  // RPS  — TODO: Tune
    // public static final double INDEXER_JAM_CURRENT_THRESHOLD   = 20.0; // amps — TODO: Tune
    // public static final double INDEXER_JAM_VELOCITY_THRESHOLD  = 0.5;  // RPS  — TODO: Tune

    // ==== Elastic Dashboard Publishers ========================================
    // Only live-match booleans belong here — everything else is covered by AK or Hoot.
    // Velocity, current, and distance signals are logged by processInputs() and Hoot;
    // publishing them to NT again would be redundant.
    private final NetworkTable    indexerTable;
    private final BooleanPublisher hopperAPublisher;
    private final BooleanPublisher hopperBPublisher;
    private final IntegerPublisher hopperCountPublisher;
    // private final BooleanPublisher hopperJammedPublisher;
    // private final BooleanPublisher indexerJammedPublisher;

    // ==== Constructor =========================================================
    public IndexerSubsystem(IndexerIO io) {
        this.io = io;

        NetworkTableInstance inst = NetworkTableInstance.getDefault();
        indexerTable = inst.getTable("Indexer");

        hopperAPublisher     = indexerTable.getBooleanTopic("HopperA").publish();
        hopperBPublisher     = indexerTable.getBooleanTopic("HopperB").publish();
        hopperCountPublisher = indexerTable.getIntegerTopic("HopperCount").publish();
        // hopperJammedPublisher  = indexerTable.getBooleanTopic("HopperJammed").publish();
        // indexerJammedPublisher = indexerTable.getBooleanTopic("IndexerJammed").publish();
    }

    // ==== Periodic ============================================================
    @Override
    public void periodic() {
        io.updateInputs(inputs);

        // processInputs() logs the raw IO layer — motor signals and sensor readings.
        // These show up in AdvantageScope under "Indexer/".
        Logger.processInputs("Indexer", inputs);

        // recordOutput() logs computed/derived values — the decisions the subsystem
        // is making on top of the raw data. Hoot can't see these; AK can.
        Logger.recordOutput("Indexer/State", currentState.name());
        Logger.recordOutput("Indexer/IsHopperFull", isHopperFull());
        Logger.recordOutput("Indexer/HopperCount", getHopperGamePieceCount());

        publishTelemetry();
    }

    // Elastic gets the sensor booleans and piece count for driver awareness.
    // State is already in AK; no need to publish it to NT as well.
    private void publishTelemetry() {
        hopperAPublisher.set(inputs.hopperADetected);
        hopperBPublisher.set(inputs.hopperBDetected);
        hopperCountPublisher.set(getHopperGamePieceCount());
        // hopperJammedPublisher.set(isHopperJammed());
        // indexerJammedPublisher.set(isIndexerJammed());
    }

    // ==== State ===============================================================
    // Private — state only changes through command factories in this class.
    // This prevents outside code from putting the subsystem into an inconsistent state.
    private void setState(IndexerState state) {
        this.currentState = state;
    }

    public IndexerState getState() {
        return currentState;
    }

    // ==== Motor Control =======================================================
    // Package-private — used only by command factories in this file.
    // setConveyorVolts / setIndexerVolts are public for superstructure overrides.
    void conveyorForward() { io.setConveyorMotor(CONVEYOR_FORWARD_VOLTAGE); }
    void conveyorReverse() { io.setConveyorMotor(CONVEYOR_REVERSE_VOLTAGE); }
    void conveyorStop()    { io.setConveyorMotor(0.0); }
    void indexerForward()  { io.setIndexerMotor(INDEXER_FORWARD_VOLTAGE); }
    void indexerReverse()  { io.setIndexerMotor(INDEXER_REVERSE_VOLTAGE); }
    void indexerStop()     { io.setIndexerMotor(0.0); }
    void stop()            { io.stop(); }

    public void setConveyorVolts(double volts) { io.setConveyorMotor(volts); }
    public void setIndexerVolts(double volts)  { io.setIndexerMotor(volts); }

    // ==== Sensor Queries ======================================================

    /** Returns true if a game piece is detected at hopper position A (front). */
    public boolean isGamePieceAtHopperA() {
        return inputs.hopperADetected;
    }

    /** Returns true if a game piece is detected at hopper position B (back). */
    public boolean isGamePieceAtHopperB() {
        return inputs.hopperBDetected;
    }

    /** Returns true if either hopper position has a game piece. */
    public boolean isGamePieceInHopper() {
        return inputs.hopperADetected || inputs.hopperBDetected;
    }

    /** Returns true if both hopper positions A and B are filled. */
    public boolean isHopperFull() {
        return inputs.hopperADetected && inputs.hopperBDetected;
    }

    /** Returns the number of game pieces detected in the hopper (0, 1, or 2). */
    public int getHopperGamePieceCount() {
        int count = 0;
        if (inputs.hopperADetected) count++;
        if (inputs.hopperBDetected) count++;
        return count;
    }

    // ==== Jam Detection =======================================================
    // Uncomment these methods and the corresponding constants and publishers
    // above once you have real current/velocity data to tune the thresholds with.
    //
    // public boolean isHopperJammed() {
    //     boolean highCurrent = inputs.conveyorCurrentAmps >= CONVEYOR_JAM_CURRENT_THRESHOLD;
    //     boolean lowVelocity = Math.abs(inputs.conveyorVelocityRPS) <= CONVEYOR_JAM_VELOCITY_THRESHOLD;
    //     return highCurrent && lowVelocity;
    // }
    //
    // public boolean isIndexerJammed() {
    //     boolean highCurrent = inputs.indexerCurrentAmps >= INDEXER_JAM_CURRENT_THRESHOLD;
    //     boolean lowVelocity = Math.abs(inputs.indexerVelocityRPS) <= INDEXER_JAM_VELOCITY_THRESHOLD;
    //     return highCurrent && lowVelocity;
    // }

    // ==== Command Factories ===================================================
    // Single-subsystem commands live here because they are tightly coupled to
    // this subsystem's motors and state. Commands that coordinate multiple
    // subsystems belong in RobotContainer or a superstructure class.

    /**
     * Runs conveyor and indexer forward while the button is held.
     * Stops and returns to IDLE on release.
     */
    public Command feed() {
        return Commands.startEnd(
            () -> {
                setState(IndexerState.FEEDING);
                conveyorForward();
                indexerForward();
            },
            () -> {
                stop();
                setState(IndexerState.IDLE);
            },
            this
        ).withName("Feed");
    }

    /**
     * Runs conveyor and indexer forward for a fixed duration, then stops.
     * Useful in autonomous sequences.
     *
     * @param durationSeconds How long to run the motors
     */
    public Command feedTimed(double durationSeconds) {
        return Commands.sequence(
            Commands.runOnce(() -> {
                setState(IndexerState.FEEDING);
                conveyorForward();
                indexerForward();
            }, this),
            Commands.waitSeconds(durationSeconds),
            Commands.runOnce(() -> {
                stop();
                setState(IndexerState.IDLE);
            }, this)
        ).withName("FeedTimed(" + durationSeconds + "s)");
    }

    /**
     * Reverses both motors for a fixed duration to clear a jam, then stops.
     *
     * @param durationSeconds How long to run in reverse
     */
    public Command eject(double durationSeconds) {
        return Commands.sequence(
            Commands.runOnce(() -> {
                setState(IndexerState.EJECTING);
                conveyorReverse();
                indexerReverse();
            }, this),
            Commands.waitSeconds(durationSeconds),
            Commands.runOnce(() -> {
                stop();
                setState(IndexerState.IDLE);
            }, this)
        ).withName("Eject(" + durationSeconds + "s)");
    }

    /** Stops all motors immediately and returns to IDLE. */
    public Command stopCommand() {
        return Commands.runOnce(() -> {
            stop();
            setState(IndexerState.IDLE);
        }, this).withName("StopIndexer");
    }
}