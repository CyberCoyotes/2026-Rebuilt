package frc.robot.subsystems.indexer;

import org.littletonrobotics.junction.Logger;

import edu.wpi.first.networktables.BooleanPublisher;
import edu.wpi.first.networktables.IntegerPublisher;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.networktables.StringPublisher;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.Commands;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

public class IndexerSubsystem extends SubsystemBase {

    // ==== Indexer State =======================================================
    /**
     * IndexerState — Tracks what the indexer is currently doing.
     *
     * Using an enum instead of Strings means a typo is a compile error,
     * not a silent bug. Compare:
     * "FEEDNG" (compiles, breaks logic silently)
     * IndexerState.FEEDNG (won't compile — caught immediately)
     */
    public enum IndexerState {
        IDLE,
        FEEDING,
        EJECTING
    }

    // ==== Hopper Fill Level ===================================================
    /**
     * HopperFillLevel — Describes how full the hopper is at a given sensor
     * position.
     *
     * Each level maps to a percentage of the usable hopper depth measured by a
     * CANrange sensor. Smaller distance = more full (pieces are closer to sensor).
     *
     * How the math works:
     * fillRatio = 1.0 - ((distance - MIN) / (MAX - MIN))
     *
     * Example with MIN=0.02m and MAX=0.40m, piece 10cm away:
     * fillRatio = 1.0 - ((0.10 - 0.02) / (0.40 - 0.02)) = 1.0 - 0.21 = 0.79 →
     * THREE_QUARTERS_FULL
     *
     * Threshold table (tune MIN/MAX constants experimentally):
     * fillRatio >= 0.90 → FULL (≤ 10% depth remaining)
     * fillRatio >= 0.75 → THREE_QUARTERS_FULL
     * fillRatio >= 0.50 → HALF_FULL
     * fillRatio >= 0.25 → QUARTER_FULL
     * fillRatio < 0.25 → EMPTY (≥ 75% depth remaining)
     */
    public enum HopperFillLevel {
        EMPTY,
        QUARTER_FULL,
        HALF_FULL,
        THREE_QUARTERS_FULL,
        FULL
    }

    // ==== IO Layer ============================================================
    private final IndexerIO io;

    // IndexerIOInputsAutoLogged is generated by @AutoLog on IndexerIOInputs.
    // This subclass implements LoggableInputs, which is what Logger.processInputs()
    // needs to write fields to the AdvantageKit log. Using plain IndexerIOInputs
    // here would silently skip all indexer data in AdvantageScope.
    private final IndexerIOInputsAutoLogged inputs = new IndexerIOInputsAutoLogged();

    // ==== State ===============================================================
    private IndexerState currentState = IndexerState.IDLE;

    // ==== Voltage Constants ===================================================
    // Kept here (alongside the commands that use them) so students can find
    // and tune these without hunting through a separate Constants file.
    public static final double CONVEYOR_FORWARD_VOLTAGE = 4.0; // TODO: Tune
    public static final double CONVEYOR_REVERSE_VOLTAGE = -4.0;
    public static final double INDEXER_FORWARD_VOLTAGE = 4.0; // TODO: Tune
    public static final double INDEXER_REVERSE_VOLTAGE = -4.0;

    // ==== Hopper Fill Level Distance Constants ================================
    // MIN = distance (meters) when hopper is packed full (piece right at sensor).
    // MAX = distance (meters) when hopper is completely empty (far wall or
    // nothing).
    //
    // HOW TO TUNE THESE:
    // 1. Watch hopperA/BDistanceMeters live in AdvantageScope or Phoenix Tuner X.
    // 2. Fill the hopper completely → record the distance. That's MIN.
    // 3. Empty the hopper completely → record the distance. That's MAX.
    // 4. Update the constants below and rebuild.
    //
    // Sensors A and B may differ slightly if they're mounted at different depths.
    public static final double HOPPER_A_MIN_DISTANCE = 0.02; // TODO: Tune experimentally
    public static final double HOPPER_A_MAX_DISTANCE = 0.40; // TODO: Tune experimentally
    public static final double HOPPER_B_MIN_DISTANCE = 0.02; // TODO: Tune experimentally
    public static final double HOPPER_B_MAX_DISTANCE = 0.40; // TODO: Tune experimentally

    // ==== Elastic Dashboard Publishers ========================================
    // Only live-match driver awareness data belongs here. Velocity, current, and
    // raw distance signals are already logged by processInputs() and Hoot;
    // publishing them to NT would be redundant.
    private final NetworkTable indexerTable;
    private final BooleanPublisher hopperAPublisher;
    private final BooleanPublisher hopperBPublisher;
    private final IntegerPublisher hopperCountPublisher;
    private final StringPublisher hopperAFillLevelPublisher; // For future Elastic widget
    private final StringPublisher hopperBFillLevelPublisher; // For future Elastic widget

    // ==== Constructor =========================================================
    public IndexerSubsystem(IndexerIO io) {
        this.io = io;

        NetworkTableInstance inst = NetworkTableInstance.getDefault();
        indexerTable = inst.getTable("Indexer");

        hopperAPublisher = indexerTable.getBooleanTopic("HopperA/Detected").publish();
        hopperBPublisher = indexerTable.getBooleanTopic("HopperB/Detected").publish();
        hopperCountPublisher = indexerTable.getIntegerTopic("HopperCount").publish();
        hopperAFillLevelPublisher = indexerTable.getStringTopic("HopperA/FillLevel").publish();
        hopperBFillLevelPublisher = indexerTable.getStringTopic("HopperB/FillLevel").publish();
    }

    // ==== Periodic ============================================================
    @Override
    public void periodic() {
        io.updateInputs(inputs);

        // processInputs() logs the raw IO layer — motor signals and sensor readings.
        // These appear in AdvantageScope under "Indexer/".
        Logger.processInputs("Indexer", inputs);

        // recordOutput() logs computed/derived values — the decisions the subsystem
        // makes on top of raw data. Hoot can't see these; AK can.
        Logger.recordOutput("Indexer/State", currentState.name());
        Logger.recordOutput("Indexer/IsHopperFull", isHopperFull());
        Logger.recordOutput("Indexer/HopperCount", getHopperGamePieceCount());
        Logger.recordOutput("Indexer/HopperA/FillLevel", getHopperAFillLevel().name());
        Logger.recordOutput("Indexer/HopperB/FillLevel", getHopperBFillLevel().name());

        publishTelemetry();
    }

    // Elastic gets the booleans, piece count, and fill levels for driver awareness.
    // State and raw distances are in AK already; no need to duplicate them in NT.
    private void publishTelemetry() {
        hopperAPublisher.set(inputs.hopperADetected);
        hopperBPublisher.set(inputs.hopperBDetected);
        hopperCountPublisher.set(getHopperGamePieceCount());
        hopperAFillLevelPublisher.set(getHopperAFillLevel().name());
        hopperBFillLevelPublisher.set(getHopperBFillLevel().name());
    }

    // ==== State ===============================================================
    private void setState(IndexerState state) {
        this.currentState = state;
    }

    public IndexerState getState() {
        return currentState;
    }

    // ==== Motor Control =======================================================
    void conveyorForward() {
        io.setConveyorMotor(CONVEYOR_FORWARD_VOLTAGE);
    }

    void conveyorReverse() {
        io.setConveyorMotor(CONVEYOR_REVERSE_VOLTAGE);
    }

    void conveyorStop() {
        io.setConveyorMotor(0.0);
    }

    void indexerForward() {
        io.setIndexerMotor(INDEXER_FORWARD_VOLTAGE);
    }

    void indexerReverse() {
        io.setIndexerMotor(INDEXER_REVERSE_VOLTAGE);
    }

    void indexerStop() {
        io.setIndexerMotor(0.0);
    }

    void stop() {
        io.stop();
    }

    public void setConveyorVolts(double volts) {
        io.setConveyorMotor(volts);
    }

    public void setIndexerVolts(double volts) {
        io.setIndexerMotor(volts);
    }

    // ==== Sensor Queries ======================================================

    /** Returns true if a game piece is detected at hopper position A (front). */
    public boolean isGamePieceAtHopperA() {
        return inputs.hopperADetected;
    }

    /** Returns true if a game piece is detected at hopper position B (back). */
    public boolean isGamePieceAtHopperB() {
        return inputs.hopperBDetected;
    }

    /** Returns true if either hopper position has a game piece. */
    public boolean isGamePieceInHopper() {
        return inputs.hopperADetected || inputs.hopperBDetected;
    }

    /** Returns true if both hopper positions A and B are filled. */
    public boolean isHopperFull() {
        return inputs.hopperADetected && inputs.hopperBDetected;
    }

    /** Returns the number of game pieces detected in the hopper (0, 1, or 2). */
    public int getHopperGamePieceCount() {
        int count = 0;
        if (inputs.hopperADetected)
            count++;
        if (inputs.hopperBDetected)
            count++;
        return count;
    }

    // ==== Hopper Fill Level ===================================================

    /**
     * Returns how full hopper position A is based on raw CANrange distance.
     *
     * Delegates to the shared helper so the math lives in one place.
     * Tune HOPPER_A_MIN/MAX_DISTANCE constants to match your physical hopper.
     */
    public HopperFillLevel getHopperAFillLevel() {
        return calculateFillLevel(
                inputs.hopperADistanceMeters,
                HOPPER_A_MIN_DISTANCE,
                HOPPER_A_MAX_DISTANCE);
    }

    /**
     * Returns how full hopper position B is based on raw CANrange distance.
     *
     * Delegates to the shared helper so the math lives in one place.
     * Tune HOPPER_B_MIN/MAX_DISTANCE constants to match your physical hopper.
     */
    public HopperFillLevel getHopperBFillLevel() {
        return calculateFillLevel(
                inputs.hopperBDistanceMeters,
                HOPPER_B_MIN_DISTANCE,
                HOPPER_B_MAX_DISTANCE);
    }

    /**
     * Converts a raw CANrange distance into a HopperFillLevel bucket.
     *
     * This is a private static helper — it only does math on the numbers
     * you hand it, with no access to subsystem state. That keeps the logic
     * easy to understand, test, and reuse for both sensors.
     *
     * Fill ratio formula:
     * fillRatio = 1.0 - clamp((distance - min) / (max - min), 0.0, 1.0)
     *
     * A fillRatio of 1.0 means pieces are right at the sensor (packed full).
     * A fillRatio of 0.0 means the sensor sees the far wall (completely empty).
     *
     * @param distanceMeters Raw CANrange reading (meters)
     * @param minDistance    Distance when hopper is completely full (meters)
     * @param maxDistance    Distance when hopper is completely empty (meters)
     * @return The appropriate HopperFillLevel bucket
     */
    private static HopperFillLevel calculateFillLevel(
            double distanceMeters,
            double minDistance,
            double maxDistance) {

        // Guard: if min and max are the same the constants aren't tuned yet.
        // Return EMPTY so the robot fails safe rather than doing weird math.
        if (maxDistance <= minDistance) {
            return HopperFillLevel.EMPTY;
        }

        // Normalize distance to a 0.0–1.0 fill ratio.
        // clamp() ensures values outside the calibrated range stay within bounds.
        double raw = (distanceMeters - minDistance) / (maxDistance - minDistance);
        double clamped = Math.max(0.0, Math.min(1.0, raw));
        double fillRatio = 1.0 - clamped; // Invert: closer = more full

        // Map fill ratio to enum bucket.
        // Read top-to-bottom: most full wins.
        if (fillRatio >= 0.90)
            return HopperFillLevel.FULL;
        if (fillRatio >= 0.75)
            return HopperFillLevel.THREE_QUARTERS_FULL;
        if (fillRatio >= 0.50)
            return HopperFillLevel.HALF_FULL;
        if (fillRatio >= 0.25)
            return HopperFillLevel.QUARTER_FULL;
        return HopperFillLevel.EMPTY;
    }

    // ==== Command Factories ===================================================
    // Single-subsystem commands live here because they are tightly coupled to
    // this subsystem's motors and state. Commands that coordinate multiple
    // subsystems belong in RobotContainer or a superstructure class.

    /**
     * Runs conveyor and indexer forward while the button is held.
     * Stops and returns to IDLE on release.
     */
    public Command feed() {
        return Commands.startEnd(
                () -> {
                    setState(IndexerState.FEEDING);
                    conveyorForward();
                    indexerForward();
                },
                () -> {
                    stop();
                    setState(IndexerState.IDLE);
                },
                this).withName("Feed Fuel");
    }

    /**
     * Runs conveyor and indexer forward for a fixed duration, then stops.
     * Useful in autonomous sequences.
     *
     * @param durationSeconds How long to run the motors
     */
    public Command feedTimed(double durationSeconds) {
        return Commands.sequence(
                Commands.runOnce(() -> {
                    setState(IndexerState.FEEDING);
                    conveyorForward();
                    indexerForward();
                }, this),
                Commands.waitSeconds(durationSeconds),
                Commands.runOnce(() -> {
                    stop();
                    setState(IndexerState.IDLE);
                }, this)).withName("Feed Fuel Timed(" + durationSeconds + "s)");
    }

    /**
     * Reverses both motors for a fixed duration to clear a jam, then stops.
     *
     * @param durationSeconds How long to run in reverse
     */
    public Command eject(double durationSeconds) {
        return Commands.sequence(
                Commands.runOnce(() -> {
                    setState(IndexerState.EJECTING);
                    conveyorReverse();
                    indexerReverse();
                }, this),
                Commands.waitSeconds(durationSeconds),
                Commands.runOnce(() -> {
                    stop();
                    setState(IndexerState.IDLE);
                }, this)).withName("Eject(" + durationSeconds + "s)");
    }

    /** Stops all motors immediately and returns to IDLE. */
    public Command stopCommand() {
        return Commands.runOnce(() -> {
            stop();
            setState(IndexerState.IDLE);
        }, this).withName("StopIndexer");
    }
}